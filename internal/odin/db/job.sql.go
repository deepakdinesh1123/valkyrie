// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: job.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const fetchJob = `-- name: FetchJob :one
UPDATE JobQueue SET started_at = current_timestamp
WHERE id = (
    SELECT id FROM JobQueue
    WHERE (completed_at IS NULL and started_at IS NULL)
    ORDER BY
        priority ASC,
        id ASC
    FOR UPDATE SKIP LOCKED
    LIMIT 1
    )
RETURNING id, created_by, created_at, started_at, completed_at, script, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id
`

func (q *Queries) FetchJob(ctx context.Context) (Jobqueue, error) {
	row := q.db.QueryRow(ctx, fetchJob)
	var i Jobqueue
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Script,
		&i.Args,
		&i.Logs,
		&i.Flake,
		&i.Language,
		&i.MemPeak,
		&i.Timeout,
		&i.Priority,
		&i.LeaseTimeout,
		&i.Queue,
		&i.JobType,
		&i.WorkerID,
	)
	return i, err
}

const getAllExecutionResults = `-- name: GetAllExecutionResults :many
SELECT id, logs, script, args FROM JobQueue
WHERE job_type = 'execution'
ORDER BY started_at
`

type GetAllExecutionResultsRow struct {
	ID     int64
	Logs   pgtype.Text
	Script pgtype.Text
	Args   []byte
}

func (q *Queries) GetAllExecutionResults(ctx context.Context) ([]GetAllExecutionResultsRow, error) {
	rows, err := q.db.Query(ctx, getAllExecutionResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllExecutionResultsRow
	for rows.Next() {
		var i GetAllExecutionResultsRow
		if err := rows.Scan(
			&i.ID,
			&i.Logs,
			&i.Script,
			&i.Args,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllExecutions = `-- name: GetAllExecutions :many
SELECT id, created_by, created_at, started_at, completed_at, script, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id FROM JobQueue
WHERE job_type = 'execution'
ORDER BY started_at
`

func (q *Queries) GetAllExecutions(ctx context.Context) ([]Jobqueue, error) {
	rows, err := q.db.Query(ctx, getAllExecutions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Jobqueue
	for rows.Next() {
		var i Jobqueue
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Script,
			&i.Args,
			&i.Logs,
			&i.Flake,
			&i.Language,
			&i.MemPeak,
			&i.Timeout,
			&i.Priority,
			&i.LeaseTimeout,
			&i.Queue,
			&i.JobType,
			&i.WorkerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJobs = `-- name: GetAllJobs :many
SELECT id, created_by, created_at, started_at, completed_at, script, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id FROM JobQueue
ORDER BY started_at
`

func (q *Queries) GetAllJobs(ctx context.Context) ([]Jobqueue, error) {
	rows, err := q.db.Query(ctx, getAllJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Jobqueue
	for rows.Next() {
		var i Jobqueue
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Script,
			&i.Args,
			&i.Logs,
			&i.Flake,
			&i.Language,
			&i.MemPeak,
			&i.Timeout,
			&i.Priority,
			&i.LeaseTimeout,
			&i.Queue,
			&i.JobType,
			&i.WorkerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJob = `-- name: GetJob :one
SELECT id, created_by, created_at, started_at, completed_at, script, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id FROM JobQueue
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetJob(ctx context.Context, id int64) (Jobqueue, error) {
	row := q.db.QueryRow(ctx, getJob, id)
	var i Jobqueue
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Script,
		&i.Args,
		&i.Logs,
		&i.Flake,
		&i.Language,
		&i.MemPeak,
		&i.Timeout,
		&i.Priority,
		&i.LeaseTimeout,
		&i.Queue,
		&i.JobType,
		&i.WorkerID,
	)
	return i, err
}

const getResultUsingExecutionID = `-- name: GetResultUsingExecutionID :one
SELECT id, created_by, created_at, started_at, completed_at, script, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id
FROM JobQueue
WHERE id = $1 AND job_type = 'execution' LIMIT 1
`

func (q *Queries) GetResultUsingExecutionID(ctx context.Context, id int64) (Jobqueue, error) {
	row := q.db.QueryRow(ctx, getResultUsingExecutionID, id)
	var i Jobqueue
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Script,
		&i.Args,
		&i.Logs,
		&i.Flake,
		&i.Language,
		&i.MemPeak,
		&i.Timeout,
		&i.Priority,
		&i.LeaseTimeout,
		&i.Queue,
		&i.JobType,
		&i.WorkerID,
	)
	return i, err
}

const insertJob = `-- name: InsertJob :one
INSERT INTO JobQueue
    (script, flake, priority)
VALUES
    ($1, $2, $3)
RETURNING id, created_by, created_at, started_at, completed_at, script, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id
`

type InsertJobParams struct {
	Script   pgtype.Text
	Flake    pgtype.Text
	Priority pgtype.Int4
}

func (q *Queries) InsertJob(ctx context.Context, arg InsertJobParams) (Jobqueue, error) {
	row := q.db.QueryRow(ctx, insertJob, arg.Script, arg.Flake, arg.Priority)
	var i Jobqueue
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Script,
		&i.Args,
		&i.Logs,
		&i.Flake,
		&i.Language,
		&i.MemPeak,
		&i.Timeout,
		&i.Priority,
		&i.LeaseTimeout,
		&i.Queue,
		&i.JobType,
		&i.WorkerID,
	)
	return i, err
}

const remainingJobs = `-- name: RemainingJobs :one
SELECT count(*) FROM JobQueue
WHERE queue=$1 AND completed_at IS NULL
`

func (q *Queries) RemainingJobs(ctx context.Context, queue string) (int64, error) {
	row := q.db.QueryRow(ctx, remainingJobs, queue)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateJob = `-- name: UpdateJob :one
UPDATE JobQueue
SET
    completed_at = current_timestamp
WHERE id = $1 AND completed_at IS NULL
RETURNING id, created_by, created_at, started_at, completed_at, script, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id
`

func (q *Queries) UpdateJob(ctx context.Context, id int64) (Jobqueue, error) {
	row := q.db.QueryRow(ctx, updateJob, id)
	var i Jobqueue
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Script,
		&i.Args,
		&i.Logs,
		&i.Flake,
		&i.Language,
		&i.MemPeak,
		&i.Timeout,
		&i.Priority,
		&i.LeaseTimeout,
		&i.Queue,
		&i.JobType,
		&i.WorkerID,
	)
	return i, err
}
