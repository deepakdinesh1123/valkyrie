// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: job.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteJob = `-- name: DeleteJob :exec
delete from jobs where id = $1 and completed = false
`

func (q *Queries) DeleteJob(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteJob, id)
	return err
}

const fetchJob = `-- name: FetchJob :one
update jobs set running = true, worker_id = $1
where id = (
    select id from jobs
    where (running = false and completed = false)
    order by
        id asc
    for update skip locked
    limit 1
    )
returning id, inserted_at, worker_id, script, script_path, args, flake, language, completed, running
`

func (q *Queries) FetchJob(ctx context.Context, workerID pgtype.Int4) (Job, error) {
	row := q.db.QueryRow(ctx, fetchJob, workerID)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.InsertedAt,
		&i.WorkerID,
		&i.Script,
		&i.ScriptPath,
		&i.Args,
		&i.Flake,
		&i.Language,
		&i.Completed,
		&i.Running,
	)
	return i, err
}

const getAllExecutionResults = `-- name: GetAllExecutionResults :many
select id, job_id, worker_id, created_at, started_at, finished_at, script, flake, args, logs from job_runs
order by started_at desc
limit $1 offset $2
`

type GetAllExecutionResultsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetAllExecutionResults(ctx context.Context, arg GetAllExecutionResultsParams) ([]JobRun, error) {
	rows, err := q.db.Query(ctx, getAllExecutionResults, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobRun
	for rows.Next() {
		var i JobRun
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.WorkerID,
			&i.CreatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Script,
			&i.Flake,
			&i.Args,
			&i.Logs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJobs = `-- name: GetAllJobs :many
select id, inserted_at, worker_id, script, script_path, args, flake, language, completed, running from jobs
limit $1 offset $2
`

type GetAllJobsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetAllJobs(ctx context.Context, arg GetAllJobsParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, getAllJobs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.InsertedAt,
			&i.WorkerID,
			&i.Script,
			&i.ScriptPath,
			&i.Args,
			&i.Flake,
			&i.Language,
			&i.Completed,
			&i.Running,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExecutionResultsByID = `-- name: GetExecutionResultsByID :many
select id, job_id, worker_id, created_at, started_at, finished_at, script, flake, args, logs from job_runs where job_id = $1
limit $2 offset $3
`

type GetExecutionResultsByIDParams struct {
	JobID  int64 `db:"job_id" json:"job_id"`
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetExecutionResultsByID(ctx context.Context, arg GetExecutionResultsByIDParams) ([]JobRun, error) {
	rows, err := q.db.Query(ctx, getExecutionResultsByID, arg.JobID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobRun
	for rows.Next() {
		var i JobRun
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.WorkerID,
			&i.CreatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Script,
			&i.Flake,
			&i.Args,
			&i.Logs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJob = `-- name: GetJob :one
select id, inserted_at, worker_id, script, script_path, args, flake, language, completed, running from jobs where id = $1
`

func (q *Queries) GetJob(ctx context.Context, id int64) (Job, error) {
	row := q.db.QueryRow(ctx, getJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.InsertedAt,
		&i.WorkerID,
		&i.Script,
		&i.ScriptPath,
		&i.Args,
		&i.Flake,
		&i.Language,
		&i.Completed,
		&i.Running,
	)
	return i, err
}

const getTotalExecutions = `-- name: GetTotalExecutions :one
select count(*) from job_runs
`

func (q *Queries) GetTotalExecutions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalExecutions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalExecutionsForJob = `-- name: GetTotalExecutionsForJob :one
select count(*) from job_runs where job_id = $1
`

func (q *Queries) GetTotalExecutionsForJob(ctx context.Context, jobID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalExecutionsForJob, jobID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalJobs = `-- name: GetTotalJobs :one
SELECT count(*) FROM jobs
`

func (q *Queries) GetTotalJobs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalJobs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertJob = `-- name: InsertJob :one
insert into jobs
    (script, flake, language, script_path, args)
values
    ($1, $2, $3, $4, $5)
returning id, inserted_at, worker_id, script, script_path, args, flake, language, completed, running
`

type InsertJobParams struct {
	Script     string      `db:"script" json:"script"`
	Flake      string      `db:"flake" json:"flake"`
	Language   string      `db:"language" json:"language"`
	ScriptPath string      `db:"script_path" json:"script_path"`
	Args       pgtype.Text `db:"args" json:"args"`
}

func (q *Queries) InsertJob(ctx context.Context, arg InsertJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, insertJob,
		arg.Script,
		arg.Flake,
		arg.Language,
		arg.ScriptPath,
		arg.Args,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.InsertedAt,
		&i.WorkerID,
		&i.Script,
		&i.ScriptPath,
		&i.Args,
		&i.Flake,
		&i.Language,
		&i.Completed,
		&i.Running,
	)
	return i, err
}

const insertJobRun = `-- name: InsertJobRun :one
insert into job_runs
    (job_id, worker_id, started_at, finished_at, script, flake, args, logs, created_at)
values
    ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning id, job_id, worker_id, created_at, started_at, finished_at, script, flake, args, logs
`

type InsertJobRunParams struct {
	JobID      int64              `db:"job_id" json:"job_id"`
	WorkerID   int32              `db:"worker_id" json:"worker_id"`
	StartedAt  pgtype.Timestamptz `db:"started_at" json:"started_at"`
	FinishedAt pgtype.Timestamptz `db:"finished_at" json:"finished_at"`
	Script     string             `db:"script" json:"script"`
	Flake      string             `db:"flake" json:"flake"`
	Args       pgtype.Text        `db:"args" json:"args"`
	Logs       string             `db:"logs" json:"logs"`
	CreatedAt  pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) InsertJobRun(ctx context.Context, arg InsertJobRunParams) (JobRun, error) {
	row := q.db.QueryRow(ctx, insertJobRun,
		arg.JobID,
		arg.WorkerID,
		arg.StartedAt,
		arg.FinishedAt,
		arg.Script,
		arg.Flake,
		arg.Args,
		arg.Logs,
		arg.CreatedAt,
	)
	var i JobRun
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.WorkerID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Script,
		&i.Flake,
		&i.Args,
		&i.Logs,
	)
	return i, err
}

const updateJob = `-- name: UpdateJob :exec
update jobs
set
    completed = true
where id = $1 AND completed = false
`

func (q *Queries) UpdateJob(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateJob, id)
	return err
}
