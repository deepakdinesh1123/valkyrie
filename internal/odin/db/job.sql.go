// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: job.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM JobQueue
WHERE id = $1 and completed_at IS NULL
`

func (q *Queries) DeleteJob(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteJob, id)
	return err
}

const fetchJob = `-- name: FetchJob :one
UPDATE JobQueue SET started_at = current_timestamp, worker_id = $1
WHERE id = (
    SELECT id FROM JobQueue
    WHERE (completed_at IS NULL and started_at IS NULL)
    ORDER BY
        priority ASC,
        id ASC
    FOR UPDATE SKIP LOCKED
    LIMIT 1
    )
RETURNING id, created_by, created_at, started_at, completed_at, script, script_path, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id
`

func (q *Queries) FetchJob(ctx context.Context, workerID pgtype.Int4) (Jobqueue, error) {
	row := q.db.QueryRow(ctx, fetchJob, workerID)
	var i Jobqueue
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Script,
		&i.ScriptPath,
		&i.Args,
		&i.Logs,
		&i.Flake,
		&i.Language,
		&i.MemPeak,
		&i.Timeout,
		&i.Priority,
		&i.LeaseTimeout,
		&i.Queue,
		&i.JobType,
		&i.WorkerID,
	)
	return i, err
}

const getAllExecutionResults = `-- name: GetAllExecutionResults :many
SELECT id, logs, script, args FROM JobQueue
WHERE job_type = 'execution'
ORDER BY started_at
`

type GetAllExecutionResultsRow struct {
	ID     int64       `db:"id" json:"id"`
	Logs   pgtype.Text `db:"logs" json:"logs"`
	Script pgtype.Text `db:"script" json:"script"`
	Args   pgtype.Text `db:"args" json:"args"`
}

func (q *Queries) GetAllExecutionResults(ctx context.Context) ([]GetAllExecutionResultsRow, error) {
	rows, err := q.db.Query(ctx, getAllExecutionResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllExecutionResultsRow
	for rows.Next() {
		var i GetAllExecutionResultsRow
		if err := rows.Scan(
			&i.ID,
			&i.Logs,
			&i.Script,
			&i.Args,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllExecutions = `-- name: GetAllExecutions :many
SELECT id, created_by, created_at, started_at, completed_at, script, script_path, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id FROM JobQueue
WHERE job_type = 'execution'
ORDER BY started_at
`

func (q *Queries) GetAllExecutions(ctx context.Context) ([]Jobqueue, error) {
	rows, err := q.db.Query(ctx, getAllExecutions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Jobqueue
	for rows.Next() {
		var i Jobqueue
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Script,
			&i.ScriptPath,
			&i.Args,
			&i.Logs,
			&i.Flake,
			&i.Language,
			&i.MemPeak,
			&i.Timeout,
			&i.Priority,
			&i.LeaseTimeout,
			&i.Queue,
			&i.JobType,
			&i.WorkerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJobs = `-- name: GetAllJobs :many
SELECT id, created_by, created_at, started_at, completed_at, script, script_path, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id FROM JobQueue
ORDER BY started_at
`

func (q *Queries) GetAllJobs(ctx context.Context) ([]Jobqueue, error) {
	rows, err := q.db.Query(ctx, getAllJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Jobqueue
	for rows.Next() {
		var i Jobqueue
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Script,
			&i.ScriptPath,
			&i.Args,
			&i.Logs,
			&i.Flake,
			&i.Language,
			&i.MemPeak,
			&i.Timeout,
			&i.Priority,
			&i.LeaseTimeout,
			&i.Queue,
			&i.JobType,
			&i.WorkerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJob = `-- name: GetJob :one
SELECT id, created_by, created_at, started_at, completed_at, script, script_path, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id FROM JobQueue
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetJob(ctx context.Context, id int64) (Jobqueue, error) {
	row := q.db.QueryRow(ctx, getJob, id)
	var i Jobqueue
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Script,
		&i.ScriptPath,
		&i.Args,
		&i.Logs,
		&i.Flake,
		&i.Language,
		&i.MemPeak,
		&i.Timeout,
		&i.Priority,
		&i.LeaseTimeout,
		&i.Queue,
		&i.JobType,
		&i.WorkerID,
	)
	return i, err
}

const getResultUsingExecutionID = `-- name: GetResultUsingExecutionID :one
SELECT id, created_by, created_at, started_at, completed_at, script, script_path, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id
FROM JobQueue
WHERE id = $1 AND job_type = 'execution' LIMIT 1
`

func (q *Queries) GetResultUsingExecutionID(ctx context.Context, id int64) (Jobqueue, error) {
	row := q.db.QueryRow(ctx, getResultUsingExecutionID, id)
	var i Jobqueue
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Script,
		&i.ScriptPath,
		&i.Args,
		&i.Logs,
		&i.Flake,
		&i.Language,
		&i.MemPeak,
		&i.Timeout,
		&i.Priority,
		&i.LeaseTimeout,
		&i.Queue,
		&i.JobType,
		&i.WorkerID,
	)
	return i, err
}

const insertJob = `-- name: InsertJob :one
INSERT INTO JobQueue
    (script, flake, language, script_path, args)
VALUES
    ($1, $2, $3, $4, $5)
RETURNING id, created_by, created_at, started_at, completed_at, script, script_path, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id
`

type InsertJobParams struct {
	Script     pgtype.Text `db:"script" json:"script"`
	Flake      pgtype.Text `db:"flake" json:"flake"`
	Language   pgtype.Text `db:"language" json:"language"`
	ScriptPath pgtype.Text `db:"script_path" json:"script_path"`
	Args       pgtype.Text `db:"args" json:"args"`
}

func (q *Queries) InsertJob(ctx context.Context, arg InsertJobParams) (Jobqueue, error) {
	row := q.db.QueryRow(ctx, insertJob,
		arg.Script,
		arg.Flake,
		arg.Language,
		arg.ScriptPath,
		arg.Args,
	)
	var i Jobqueue
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Script,
		&i.ScriptPath,
		&i.Args,
		&i.Logs,
		&i.Flake,
		&i.Language,
		&i.MemPeak,
		&i.Timeout,
		&i.Priority,
		&i.LeaseTimeout,
		&i.Queue,
		&i.JobType,
		&i.WorkerID,
	)
	return i, err
}

const remainingJobs = `-- name: RemainingJobs :one
SELECT count(*) FROM JobQueue
WHERE queue=$1 AND completed_at IS NULL
`

func (q *Queries) RemainingJobs(ctx context.Context, queue string) (int64, error) {
	row := q.db.QueryRow(ctx, remainingJobs, queue)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateJob = `-- name: UpdateJob :one
UPDATE JobQueue
SET
    completed_at = current_timestamp
    , logs = $2
WHERE id = $1 AND completed_at IS NULL
RETURNING id, created_by, created_at, started_at, completed_at, script, script_path, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id
`

type UpdateJobParams struct {
	ID   int64       `db:"id" json:"id"`
	Logs pgtype.Text `db:"logs" json:"logs"`
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (Jobqueue, error) {
	row := q.db.QueryRow(ctx, updateJob, arg.ID, arg.Logs)
	var i Jobqueue
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Script,
		&i.ScriptPath,
		&i.Args,
		&i.Logs,
		&i.Flake,
		&i.Language,
		&i.MemPeak,
		&i.Timeout,
		&i.Priority,
		&i.LeaseTimeout,
		&i.Queue,
		&i.JobType,
		&i.WorkerID,
	)
	return i, err
}
