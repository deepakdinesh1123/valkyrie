// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: job.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelJob = `-- name: CancelJob :exec
update jobs set current_state = 'cancelled', updated_at = now(), worker_id = null where id = $1
`

func (q *Queries) CancelJob(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, cancelJob, id)
	return err
}

const deleteJob = `-- name: DeleteJob :exec
delete from jobs where id = $1 and completed = false
`

func (q *Queries) DeleteJob(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteJob, id)
	return err
}

const fetchJob = `-- name: FetchJob :one
update jobs set current_state = 'scheduled', started_at = now(), worker_id = $1, updated_at = now()
where id = (
    select id from jobs
    where 
        current_state = 'pending'
        and retries < max_retries
    order by
        id asc
    for update skip locked
    limit 1
    )
returning id, created_at, updated_at, time_out, started_at, exec_request_id, current_state, retries, max_retries, worker_id
`

func (q *Queries) FetchJob(ctx context.Context, workerID pgtype.Int4) (Job, error) {
	row := q.db.QueryRow(ctx, fetchJob, workerID)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TimeOut,
		&i.StartedAt,
		&i.ExecRequestID,
		&i.CurrentState,
		&i.Retries,
		&i.MaxRetries,
		&i.WorkerID,
	)
	return i, err
}

const getAllExecutionResults = `-- name: GetAllExecutionResults :many
select job_runs.id, job_id, worker_id, started_at, finished_at, exec_request_id, exec_logs, nix_logs, success, exec_request.id, hash, code, path, flake, args, programming_language from job_runs
inner join exec_request on job_runs.exec_request_id = exec_request.id
order by started_at desc
limit $1 offset $2
`

type GetAllExecutionResultsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type GetAllExecutionResultsRow struct {
	ID                  int64              `db:"id" json:"id"`
	JobID               pgtype.Int8        `db:"job_id" json:"job_id"`
	WorkerID            pgtype.Int4        `db:"worker_id" json:"worker_id"`
	StartedAt           pgtype.Timestamptz `db:"started_at" json:"started_at"`
	FinishedAt          pgtype.Timestamptz `db:"finished_at" json:"finished_at"`
	ExecRequestID       pgtype.Int4        `db:"exec_request_id" json:"exec_request_id"`
	ExecLogs            string             `db:"exec_logs" json:"exec_logs"`
	NixLogs             pgtype.Text        `db:"nix_logs" json:"nix_logs"`
	Success             pgtype.Bool        `db:"success" json:"success"`
	ID_2                int32              `db:"id_2" json:"id_2"`
	Hash                string             `db:"hash" json:"hash"`
	Code                string             `db:"code" json:"code"`
	Path                string             `db:"path" json:"path"`
	Flake               string             `db:"flake" json:"flake"`
	Args                pgtype.Text        `db:"args" json:"args"`
	ProgrammingLanguage pgtype.Text        `db:"programming_language" json:"programming_language"`
}

func (q *Queries) GetAllExecutionResults(ctx context.Context, arg GetAllExecutionResultsParams) ([]GetAllExecutionResultsRow, error) {
	rows, err := q.db.Query(ctx, getAllExecutionResults, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllExecutionResultsRow
	for rows.Next() {
		var i GetAllExecutionResultsRow
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.WorkerID,
			&i.StartedAt,
			&i.FinishedAt,
			&i.ExecRequestID,
			&i.ExecLogs,
			&i.NixLogs,
			&i.Success,
			&i.ID_2,
			&i.Hash,
			&i.Code,
			&i.Path,
			&i.Flake,
			&i.Args,
			&i.ProgrammingLanguage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJobs = `-- name: GetAllJobs :many
select jobs.id, created_at, updated_at, time_out, started_at, exec_request_id, current_state, retries, max_retries, worker_id, exec_request.id, hash, code, path, flake, args, programming_language from jobs
inner join exec_request on jobs.exec_request_id = exec_request.id
order by jobs.id
limit $1 offset $2
`

type GetAllJobsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type GetAllJobsRow struct {
	ID                  int64              `db:"id" json:"id"`
	CreatedAt           pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	TimeOut             pgtype.Int4        `db:"time_out" json:"time_out"`
	StartedAt           pgtype.Timestamptz `db:"started_at" json:"started_at"`
	ExecRequestID       pgtype.Int4        `db:"exec_request_id" json:"exec_request_id"`
	CurrentState        string             `db:"current_state" json:"current_state"`
	Retries             pgtype.Int4        `db:"retries" json:"retries"`
	MaxRetries          pgtype.Int4        `db:"max_retries" json:"max_retries"`
	WorkerID            pgtype.Int4        `db:"worker_id" json:"worker_id"`
	ID_2                int32              `db:"id_2" json:"id_2"`
	Hash                string             `db:"hash" json:"hash"`
	Code                string             `db:"code" json:"code"`
	Path                string             `db:"path" json:"path"`
	Flake               string             `db:"flake" json:"flake"`
	Args                pgtype.Text        `db:"args" json:"args"`
	ProgrammingLanguage pgtype.Text        `db:"programming_language" json:"programming_language"`
}

func (q *Queries) GetAllJobs(ctx context.Context, arg GetAllJobsParams) ([]GetAllJobsRow, error) {
	rows, err := q.db.Query(ctx, getAllJobs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllJobsRow
	for rows.Next() {
		var i GetAllJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TimeOut,
			&i.StartedAt,
			&i.ExecRequestID,
			&i.CurrentState,
			&i.Retries,
			&i.MaxRetries,
			&i.WorkerID,
			&i.ID_2,
			&i.Hash,
			&i.Code,
			&i.Path,
			&i.Flake,
			&i.Args,
			&i.ProgrammingLanguage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExecutionResultsByID = `-- name: GetExecutionResultsByID :many
select job_runs.id, job_id, worker_id, started_at, finished_at, exec_request_id, exec_logs, nix_logs, success, exec_request.id, hash, code, path, flake, args, programming_language from job_runs
inner join exec_request on job_runs.exec_request_id = exec_request.id
where job_runs.job_id = $1
order by finished_at desc
limit $2 offset $3
`

type GetExecutionResultsByIDParams struct {
	JobID  pgtype.Int8 `db:"job_id" json:"job_id"`
	Limit  int32       `db:"limit" json:"limit"`
	Offset int32       `db:"offset" json:"offset"`
}

type GetExecutionResultsByIDRow struct {
	ID                  int64              `db:"id" json:"id"`
	JobID               pgtype.Int8        `db:"job_id" json:"job_id"`
	WorkerID            pgtype.Int4        `db:"worker_id" json:"worker_id"`
	StartedAt           pgtype.Timestamptz `db:"started_at" json:"started_at"`
	FinishedAt          pgtype.Timestamptz `db:"finished_at" json:"finished_at"`
	ExecRequestID       pgtype.Int4        `db:"exec_request_id" json:"exec_request_id"`
	ExecLogs            string             `db:"exec_logs" json:"exec_logs"`
	NixLogs             pgtype.Text        `db:"nix_logs" json:"nix_logs"`
	Success             pgtype.Bool        `db:"success" json:"success"`
	ID_2                int32              `db:"id_2" json:"id_2"`
	Hash                string             `db:"hash" json:"hash"`
	Code                string             `db:"code" json:"code"`
	Path                string             `db:"path" json:"path"`
	Flake               string             `db:"flake" json:"flake"`
	Args                pgtype.Text        `db:"args" json:"args"`
	ProgrammingLanguage pgtype.Text        `db:"programming_language" json:"programming_language"`
}

func (q *Queries) GetExecutionResultsByID(ctx context.Context, arg GetExecutionResultsByIDParams) ([]GetExecutionResultsByIDRow, error) {
	rows, err := q.db.Query(ctx, getExecutionResultsByID, arg.JobID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExecutionResultsByIDRow
	for rows.Next() {
		var i GetExecutionResultsByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.WorkerID,
			&i.StartedAt,
			&i.FinishedAt,
			&i.ExecRequestID,
			&i.ExecLogs,
			&i.NixLogs,
			&i.Success,
			&i.ID_2,
			&i.Hash,
			&i.Code,
			&i.Path,
			&i.Flake,
			&i.Args,
			&i.ProgrammingLanguage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJob = `-- name: GetJob :one
select jobs.id, created_at, updated_at, time_out, started_at, exec_request_id, current_state, retries, max_retries, worker_id, exec_request.id, hash, code, path, flake, args, programming_language from jobs inner join exec_request on jobs.exec_request_id = exec_request.id where jobs.id = $1
`

type GetJobRow struct {
	ID                  int64              `db:"id" json:"id"`
	CreatedAt           pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	TimeOut             pgtype.Int4        `db:"time_out" json:"time_out"`
	StartedAt           pgtype.Timestamptz `db:"started_at" json:"started_at"`
	ExecRequestID       pgtype.Int4        `db:"exec_request_id" json:"exec_request_id"`
	CurrentState        string             `db:"current_state" json:"current_state"`
	Retries             pgtype.Int4        `db:"retries" json:"retries"`
	MaxRetries          pgtype.Int4        `db:"max_retries" json:"max_retries"`
	WorkerID            pgtype.Int4        `db:"worker_id" json:"worker_id"`
	ID_2                int32              `db:"id_2" json:"id_2"`
	Hash                string             `db:"hash" json:"hash"`
	Code                string             `db:"code" json:"code"`
	Path                string             `db:"path" json:"path"`
	Flake               string             `db:"flake" json:"flake"`
	Args                pgtype.Text        `db:"args" json:"args"`
	ProgrammingLanguage pgtype.Text        `db:"programming_language" json:"programming_language"`
}

func (q *Queries) GetJob(ctx context.Context, id int64) (GetJobRow, error) {
	row := q.db.QueryRow(ctx, getJob, id)
	var i GetJobRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TimeOut,
		&i.StartedAt,
		&i.ExecRequestID,
		&i.CurrentState,
		&i.Retries,
		&i.MaxRetries,
		&i.WorkerID,
		&i.ID_2,
		&i.Hash,
		&i.Code,
		&i.Path,
		&i.Flake,
		&i.Args,
		&i.ProgrammingLanguage,
	)
	return i, err
}

const getTotalExecutions = `-- name: GetTotalExecutions :one
select count(*) from job_runs
`

func (q *Queries) GetTotalExecutions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalExecutions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalExecutionsForJob = `-- name: GetTotalExecutionsForJob :one
select count(*) from job_runs where job_id = $1
`

func (q *Queries) GetTotalExecutionsForJob(ctx context.Context, jobID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalExecutionsForJob, jobID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalJobs = `-- name: GetTotalJobs :one
SELECT count(*) FROM jobs
`

func (q *Queries) GetTotalJobs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalJobs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertJob = `-- name: InsertJob :one
insert into jobs
    (exec_request_id, max_retries, time_out)
values
    ($1, $2, $3)
returning id, created_at, updated_at, time_out, started_at, exec_request_id, current_state, retries, max_retries, worker_id
`

type InsertJobParams struct {
	ExecRequestID pgtype.Int4 `db:"exec_request_id" json:"exec_request_id"`
	MaxRetries    pgtype.Int4 `db:"max_retries" json:"max_retries"`
	TimeOut       pgtype.Int4 `db:"time_out" json:"time_out"`
}

func (q *Queries) InsertJob(ctx context.Context, arg InsertJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, insertJob, arg.ExecRequestID, arg.MaxRetries, arg.TimeOut)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TimeOut,
		&i.StartedAt,
		&i.ExecRequestID,
		&i.CurrentState,
		&i.Retries,
		&i.MaxRetries,
		&i.WorkerID,
	)
	return i, err
}

const insertJobRun = `-- name: InsertJobRun :one
insert into job_runs
    (job_id, worker_id, started_at, finished_at, exec_request_id, exec_logs, nix_logs, success)
values
    ($1, $2, $3, $4, $5, $6, $7, $8)
returning id, job_id, worker_id, started_at, finished_at, exec_request_id, exec_logs, nix_logs, success
`

type InsertJobRunParams struct {
	JobID         pgtype.Int8        `db:"job_id" json:"job_id"`
	WorkerID      pgtype.Int4        `db:"worker_id" json:"worker_id"`
	StartedAt     pgtype.Timestamptz `db:"started_at" json:"started_at"`
	FinishedAt    pgtype.Timestamptz `db:"finished_at" json:"finished_at"`
	ExecRequestID pgtype.Int4        `db:"exec_request_id" json:"exec_request_id"`
	ExecLogs      string             `db:"exec_logs" json:"exec_logs"`
	NixLogs       pgtype.Text        `db:"nix_logs" json:"nix_logs"`
	Success       pgtype.Bool        `db:"success" json:"success"`
}

func (q *Queries) InsertJobRun(ctx context.Context, arg InsertJobRunParams) (JobRun, error) {
	row := q.db.QueryRow(ctx, insertJobRun,
		arg.JobID,
		arg.WorkerID,
		arg.StartedAt,
		arg.FinishedAt,
		arg.ExecRequestID,
		arg.ExecLogs,
		arg.NixLogs,
		arg.Success,
	)
	var i JobRun
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.WorkerID,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ExecRequestID,
		&i.ExecLogs,
		&i.NixLogs,
		&i.Success,
	)
	return i, err
}

const pruneCompletedJobs = `-- name: PruneCompletedJobs :exec
delete from jobs where current_state = 'completed'
`

func (q *Queries) PruneCompletedJobs(ctx context.Context) error {
	_, err := q.db.Exec(ctx, pruneCompletedJobs)
	return err
}

const requeueLTJobs = `-- name: RequeueLTJobs :exec
update jobs
set
    current_state = 'pending',
    updated_at = now(),
    worker_id = null
where current_state = 'scheduled' 
  and started_at + time_out * INTERVAL '1 second' < now() and time_out > 0
`

func (q *Queries) RequeueLTJobs(ctx context.Context) error {
	_, err := q.db.Exec(ctx, requeueLTJobs)
	return err
}

const requeueWorkerJobs = `-- name: RequeueWorkerJobs :exec
update jobs
set
    current_state = 'pending',
    worker_id = null,
    updated_at = now()
where current_state = 'scheduled' 
  and worker_id = $1
`

func (q *Queries) RequeueWorkerJobs(ctx context.Context, workerID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, requeueWorkerJobs, workerID)
	return err
}

const retryJob = `-- name: RetryJob :exec
update jobs
set
    current_state = 'pending',
    retries = retries::integer + 1,
    updated_at = now(),
    worker_id = null
where id = $1 AND current_state = 'scheduled'
`

func (q *Queries) RetryJob(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, retryJob, id)
	return err
}

const stopJob = `-- name: StopJob :exec
update jobs set current_state = 'pending', updated_at = now(), worker_id = null where id = $1
`

func (q *Queries) StopJob(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, stopJob, id)
	return err
}

const updateJobCompleted = `-- name: UpdateJobCompleted :exec
update jobs
set
    current_state = 'completed',
    updated_at = now()
where id = $1 AND current_state = 'scheduled'
`

func (q *Queries) UpdateJobCompleted(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateJobCompleted, id)
	return err
}

const updateJobFailed = `-- name: updateJobFailed :exec
update jobs
set
    current_state = 'failed',
    updated_at = now()
where id = $1 AND current_state = 'scheduled'
`

func (q *Queries) updateJobFailed(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateJobFailed, id)
	return err
}
