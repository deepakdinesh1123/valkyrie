// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: job.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM JobQueue
WHERE id = $1 and completed_at IS NULL
`

func (q *Queries) DeleteJob(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteJob, id)
	return err
}

const fetchJob = `-- name: FetchJob :one
UPDATE JobQueue SET started_at = current_timestamp, worker_id = $1
WHERE id = (
    SELECT id FROM JobQueue
    WHERE (completed_at IS NULL and started_at IS NULL)
    ORDER BY
        priority ASC,
        id ASC
    FOR UPDATE SKIP LOCKED
    LIMIT 1
    )
RETURNING id, created_by, created_at, started_at, completed_at, script, script_path, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id
`

func (q *Queries) FetchJob(ctx context.Context, workerID pgtype.Int4) (Jobqueue, error) {
	row := q.db.QueryRow(ctx, fetchJob, workerID)
	var i Jobqueue
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Script,
		&i.ScriptPath,
		&i.Args,
		&i.Logs,
		&i.Flake,
		&i.Language,
		&i.MemPeak,
		&i.Timeout,
		&i.Priority,
		&i.LeaseTimeout,
		&i.Queue,
		&i.JobType,
		&i.WorkerID,
	)
	return i, err
}

const getAllJobs = `-- name: GetAllJobs :many
SELECT id, created_by, created_at, started_at, completed_at, script, script_path, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id, count(*) OVER() AS total FROM JobQueue
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllJobsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type GetAllJobsRow struct {
	ID           int64            `db:"id" json:"id"`
	CreatedBy    pgtype.Text      `db:"created_by" json:"created_by"`
	CreatedAt    pgtype.Timestamp `db:"created_at" json:"created_at"`
	StartedAt    pgtype.Timestamp `db:"started_at" json:"started_at"`
	CompletedAt  pgtype.Timestamp `db:"completed_at" json:"completed_at"`
	Script       pgtype.Text      `db:"script" json:"script"`
	ScriptPath   pgtype.Text      `db:"script_path" json:"script_path"`
	Args         pgtype.Text      `db:"args" json:"args"`
	Logs         pgtype.Text      `db:"logs" json:"logs"`
	Flake        pgtype.Text      `db:"flake" json:"flake"`
	Language     pgtype.Text      `db:"language" json:"language"`
	MemPeak      pgtype.Int4      `db:"mem_peak" json:"mem_peak"`
	Timeout      pgtype.Int4      `db:"timeout" json:"timeout"`
	Priority     pgtype.Int4      `db:"priority" json:"priority"`
	LeaseTimeout pgtype.Float8    `db:"lease_timeout" json:"lease_timeout"`
	Queue        string           `db:"queue" json:"queue"`
	JobType      string           `db:"job_type" json:"job_type"`
	WorkerID     pgtype.Int4      `db:"worker_id" json:"worker_id"`
	Total        int64            `db:"total" json:"total"`
}

func (q *Queries) GetAllJobs(ctx context.Context, arg GetAllJobsParams) ([]GetAllJobsRow, error) {
	rows, err := q.db.Query(ctx, getAllJobs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllJobsRow
	for rows.Next() {
		var i GetAllJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Script,
			&i.ScriptPath,
			&i.Args,
			&i.Logs,
			&i.Flake,
			&i.Language,
			&i.MemPeak,
			&i.Timeout,
			&i.Priority,
			&i.LeaseTimeout,
			&i.Queue,
			&i.JobType,
			&i.WorkerID,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJob = `-- name: GetJob :one
SELECT id, created_by, created_at, started_at, completed_at, script, script_path, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id FROM JobQueue
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetJob(ctx context.Context, id int64) (Jobqueue, error) {
	row := q.db.QueryRow(ctx, getJob, id)
	var i Jobqueue
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Script,
		&i.ScriptPath,
		&i.Args,
		&i.Logs,
		&i.Flake,
		&i.Language,
		&i.MemPeak,
		&i.Timeout,
		&i.Priority,
		&i.LeaseTimeout,
		&i.Queue,
		&i.JobType,
		&i.WorkerID,
	)
	return i, err
}

const getResultUsingExecutionID = `-- name: GetResultUsingExecutionID :one
SELECT id, created_by, created_at, started_at, completed_at, script, script_path, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id
FROM JobQueue
WHERE id = $1 AND job_type = 'execution' LIMIT 1
`

func (q *Queries) GetResultUsingExecutionID(ctx context.Context, id int64) (Jobqueue, error) {
	row := q.db.QueryRow(ctx, getResultUsingExecutionID, id)
	var i Jobqueue
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Script,
		&i.ScriptPath,
		&i.Args,
		&i.Logs,
		&i.Flake,
		&i.Language,
		&i.MemPeak,
		&i.Timeout,
		&i.Priority,
		&i.LeaseTimeout,
		&i.Queue,
		&i.JobType,
		&i.WorkerID,
	)
	return i, err
}

const getTotalJobs = `-- name: GetTotalJobs :one
SELECT count(*) FROM JobQueue
`

func (q *Queries) GetTotalJobs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalJobs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertJob = `-- name: InsertJob :one
INSERT INTO JobQueue
    (script, flake, language, script_path, args)
VALUES
    ($1, $2, $3, $4, $5)
RETURNING id, created_by, created_at, started_at, completed_at, script, script_path, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id
`

type InsertJobParams struct {
	Script     pgtype.Text `db:"script" json:"script"`
	Flake      pgtype.Text `db:"flake" json:"flake"`
	Language   pgtype.Text `db:"language" json:"language"`
	ScriptPath pgtype.Text `db:"script_path" json:"script_path"`
	Args       pgtype.Text `db:"args" json:"args"`
}

func (q *Queries) InsertJob(ctx context.Context, arg InsertJobParams) (Jobqueue, error) {
	row := q.db.QueryRow(ctx, insertJob,
		arg.Script,
		arg.Flake,
		arg.Language,
		arg.ScriptPath,
		arg.Args,
	)
	var i Jobqueue
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Script,
		&i.ScriptPath,
		&i.Args,
		&i.Logs,
		&i.Flake,
		&i.Language,
		&i.MemPeak,
		&i.Timeout,
		&i.Priority,
		&i.LeaseTimeout,
		&i.Queue,
		&i.JobType,
		&i.WorkerID,
	)
	return i, err
}

const updateJob = `-- name: UpdateJob :one
UPDATE JobQueue
SET
    completed_at = current_timestamp
    , logs = $2
WHERE id = $1 AND completed_at IS NULL
RETURNING id, created_by, created_at, started_at, completed_at, script, script_path, args, logs, flake, language, mem_peak, timeout, priority, lease_timeout, queue, job_type, worker_id
`

type UpdateJobParams struct {
	ID   int64       `db:"id" json:"id"`
	Logs pgtype.Text `db:"logs" json:"logs"`
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (Jobqueue, error) {
	row := q.db.QueryRow(ctx, updateJob, arg.ID, arg.Logs)
	var i Jobqueue
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Script,
		&i.ScriptPath,
		&i.Args,
		&i.Logs,
		&i.Flake,
		&i.Language,
		&i.MemPeak,
		&i.Timeout,
		&i.Priority,
		&i.LeaseTimeout,
		&i.Queue,
		&i.JobType,
		&i.WorkerID,
	)
	return i, err
}
